<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helion Species Assets - SS14 Downloads</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            background: linear-gradient(135deg, #2d1b69, #9d4edd);
            border-radius: 10px;
        }
        
        .header h1 {
            margin: 0;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .asset-card {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #444;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .asset-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(157, 78, 221, 0.3);
        }
        
        .asset-title {
            color: #9d4edd;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        .preview-container {
            text-align: center;
            margin: 15px 0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a1a;
            border-radius: 5px;
            border: 1px solid #444;
        }
        
        .preview-sprite {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            max-width: 64px;
            max-height: 64px;
        }
        
        .download-btn {
            background: linear-gradient(45deg, #9d4edd, #ff6b3a);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            width: 100%;
            transition: all 0.3s;
            margin-top: 10px;
        }
        
        .download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(157, 78, 221, 0.4);
        }
        
        .download-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .master-download {
            background: #333;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #9d4edd;
        }
        
        .master-download h3 {
            color: #9d4edd;
            margin-top: 0;
        }
        
        .master-btn {
            background: linear-gradient(45deg, #9d4edd, #ff6b3a);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .master-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(157, 78, 221, 0.4);
        }
        
        .status {
            margin-top: 10px;
            font-size: 14px;
            min-height: 20px;
        }
        
        .error {
            color: #ff6b3a;
        }
        
        .success {
            color: #4edd9d;
        }
        
        .info {
            background: #2a2a2a;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            border-left: 4px solid #9d4edd;
        }
        
        .directions-preview {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .direction-sprite {
            image-rendering: pixelated;
            width: 32px;
            height: 32px;
            border: 1px solid #444;
            background: #1a1a1a;
        }
        
        .animation-preview {
            position: relative;
            width: 64px;
            height: 64px;
            margin: 0 auto;
        }
        
        .animation-preview img {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        .animation-preview img.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ”¥ Helion Species Assets ðŸ”¥</h1>
        <p>Ready-to-import .RSI bundles for Space Station 14</p>
    </div>

    <div class="info">
        <h3>ðŸ“‹ Asset Information</h3>
        <ul>
            <li><strong>Format:</strong> SS14 .RSI bundles with meta.json</li>
            <li><strong>Size:</strong> 32Ã—32 pixels</li>
            <li><strong>Directions:</strong> 4-way (South, North, West, East)</li>
            <li><strong>License:</strong> CC-BY-SA-3.0</li>
        </ul>
    </div>

    <div class="asset-grid">
        <div class="asset-card">
            <div class="asset-title">ðŸ”¥ Helion Base Body (4-dir)</div>
            <div class="preview-container">
                <div class="directions-preview" id="base-preview">
                    <!-- Generated sprites will go here -->
                </div>
            </div>
            <p>Fixed north frame with visible neck and legs, consistent silhouette across all directions.</p>
            <button class="download-btn" onclick="downloadAsset('base')">
                Download Helion Base Body
            </button>
            <div class="status" id="base-status"></div>
        </div>

        <div class="asset-card">
            <div class="asset-title">ðŸŒŠ Thermal Fins (4-dir)</div>
            <div class="preview-container">
                <div class="directions-preview" id="fins-preview">
                    <!-- Generated sprites will go here -->
                </div>
            </div>
            <p>Thermal regulation overlay compatible with the fixed north frame.</p>
            <button class="download-btn" onclick="downloadAsset('fins')">
                Download Thermal Fins
            </button>
            <div class="status" id="fins-status"></div>
        </div>

        <div class="asset-card">
            <div class="asset-title">âœ¨ Radiant Veil (4-dir)</div>
            <div class="preview-container">
                <div class="directions-preview" id="veil-preview">
                    <!-- Generated sprites will go here -->
                </div>
            </div>
            <p>Energy field overlay that doesn't occlude neck and legs.</p>
            <button class="download-btn" onclick="downloadAsset('veil')">
                Download Radiant Veil
            </button>
            <div class="status" id="veil-status"></div>
        </div>

        <div class="asset-card">
            <div class="asset-title">ðŸ’¥ Plasma Flare VFX (12f)</div>
            <div class="preview-container">
                <div class="animation-preview" id="flare-preview">
                    <!-- Generated animation frames will go here -->
                </div>
            </div>
            <p>Radial blast rings with ember sparks. Magenta/ember colorway with additive highlights.</p>
            <button class="download-btn" onclick="downloadAsset('flare')">
                Download Plasma Flare VFX
            </button>
            <div class="status" id="flare-status"></div>
        </div>
    </div>

    <div class="master-download">
        <h3>ðŸ“¦ Download All Assets</h3>
        <p>Get all Helion assets in one convenient package</p>
        <button class="master-btn" onclick="downloadAll()">
            Download ALL (.zip)
        </button>
        <div class="status" id="master-status"></div>
    </div>

    <script>
        // Basic ZIP implementation with proper ZIP file structure
        class BasicZip {
            constructor() {
                this.files = [];
            }
            
            file(name, content) {
                this.files.push({ name, content });
            }
            
            async generateAsync(options = {}) {
                // Create a basic ZIP file structure
                const zip = new ZipBuilder();
                
                for (const file of this.files) {
                    let data;
                    if (file.content instanceof Blob) {
                        data = new Uint8Array(await file.content.arrayBuffer());
                    } else if (typeof file.content === 'string') {
                        data = new TextEncoder().encode(file.content);
                    } else {
                        data = new Uint8Array(file.content);
                    }
                    zip.addFile(file.name, data);
                }
                
                return new Blob([zip.build()], { type: 'application/zip' });
            }
        }
        
        // Basic ZIP file format builder
        class ZipBuilder {
            constructor() {
                this.entries = [];
                this.centralDirectory = [];
            }
            
            addFile(name, data) {
                const nameBytes = new TextEncoder().encode(name);
                const crc32 = this.calculateCRC32(data);
                
                // Local file header
                const localHeader = new ArrayBuffer(30 + nameBytes.length);
                const localView = new DataView(localHeader);
                
                // Local file header signature
                localView.setUint32(0, 0x04034b50, true);
                // Version needed to extract
                localView.setUint16(4, 10, true);
                // General purpose bit flag
                localView.setUint16(6, 0, true);
                // Compression method (0 = stored)
                localView.setUint16(8, 0, true);
                // File modification time
                localView.setUint16(10, 0, true);
                // File modification date
                localView.setUint16(12, 0, true);
                // CRC-32
                localView.setUint32(14, crc32, true);
                // Compressed size
                localView.setUint32(18, data.length, true);
                // Uncompressed size
                localView.setUint32(22, data.length, true);
                // File name length
                localView.setUint16(26, nameBytes.length, true);
                // Extra field length
                localView.setUint16(28, 0, true);
                
                // Copy filename
                new Uint8Array(localHeader, 30).set(nameBytes);
                
                const entry = {
                    localHeader: new Uint8Array(localHeader),
                    data: data,
                    name: nameBytes,
                    crc32: crc32,
                    size: data.length
                };
                
                this.entries.push(entry);
            }
            
            build() {
                let offset = 0;
                const parts = [];
                
                // Write local file headers and data
                for (const entry of this.entries) {
                    const centralDirHeader = new ArrayBuffer(46 + entry.name.length);
                    const centralView = new DataView(centralDirHeader);
                    
                    // Central directory header signature
                    centralView.setUint32(0, 0x02014b50, true);
                    // Version made by
                    centralView.setUint16(4, 10, true);
                    // Version needed to extract
                    centralView.setUint16(6, 10, true);
                    // General purpose bit flag
                    centralView.setUint16(8, 0, true);
                    // Compression method
                    centralView.setUint16(10, 0, true);
                    // File modification time
                    centralView.setUint16(12, 0, true);
                    // File modification date
                    centralView.setUint16(14, 0, true);
                    // CRC-32
                    centralView.setUint32(16, entry.crc32, true);
                    // Compressed size
                    centralView.setUint32(20, entry.size, true);
                    // Uncompressed size
                    centralView.setUint32(24, entry.size, true);
                    // File name length
                    centralView.setUint16(28, entry.name.length, true);
                    // Extra field length
                    centralView.setUint16(30, 0, true);
                    // File comment length
                    centralView.setUint16(32, 0, true);
                    // Disk number start
                    centralView.setUint16(34, 0, true);
                    // Internal file attributes
                    centralView.setUint16(36, 0, true);
                    // External file attributes
                    centralView.setUint32(38, 0, true);
                    // Relative offset of local header
                    centralView.setUint32(42, offset, true);
                    
                    // Copy filename
                    new Uint8Array(centralDirHeader, 46).set(entry.name);
                    
                    this.centralDirectory.push(new Uint8Array(centralDirHeader));
                    
                    parts.push(entry.localHeader);
                    parts.push(entry.data);
                    offset += entry.localHeader.length + entry.data.length;
                }
                
                // Central directory
                const centralDirOffset = offset;
                let centralDirSize = 0;
                
                for (const centralHeader of this.centralDirectory) {
                    parts.push(centralHeader);
                    centralDirSize += centralHeader.length;
                }
                
                // End of central directory record
                const endOfCentralDir = new ArrayBuffer(22);
                const endView = new DataView(endOfCentralDir);
                
                // End of central dir signature
                endView.setUint32(0, 0x06054b50, true);
                // Number of this disk
                endView.setUint16(4, 0, true);
                // Number of the disk with the start of the central directory
                endView.setUint16(6, 0, true);
                // Total number of entries in the central directory on this disk
                endView.setUint16(8, this.entries.length, true);
                // Total number of entries in the central directory
                endView.setUint16(10, this.entries.length, true);
                // Size of the central directory
                endView.setUint32(12, centralDirSize, true);
                // Offset of start of central directory
                endView.setUint32(16, centralDirOffset, true);
                // ZIP file comment length
                endView.setUint16(20, 0, true);
                
                parts.push(new Uint8Array(endOfCentralDir));
                
                // Combine all parts
                const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
                const result = new Uint8Array(totalSize);
                let pos = 0;
                
                for (const part of parts) {
                    result.set(part, pos);
                    pos += part.length;
                }
                
                return result;
            }
            
            calculateCRC32(data) {
                const crcTable = this.makeCRCTable();
                let crc = 0 ^ (-1);
                
                for (let i = 0; i < data.length; i++) {
                    crc = (crc >>> 8) ^ crcTable[(crc ^ data[i]) & 0xFF];
                }
                
                return (crc ^ (-1)) >>> 0;
            }
            
            makeCRCTable() {
                if (this._crcTable) return this._crcTable;
                
                const crcTable = [];
                for (let n = 0; n < 256; n++) {
                    let c = n;
                    for (let k = 0; k < 8; k++) {
                        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                    }
                    crcTable[n] = c;
                }
                this._crcTable = crcTable;
                return crcTable;
            }
        }
        
        // Make it compatible with JSZip API
        window.JSZip = BasicZip;
    </script>
    <script>
        // Asset generation and download system
        class HelionAssetGenerator {
            constructor() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 32;
                this.canvas.height = 32;
                
                // Initialize previews
                this.generatePreviews();
                this.startFlareAnimation();
            }
            
            // Generate SVG for Helion base body (4 directions)
            generateBaseSVG(direction) {
                const colors = {
                    body: '#4a3c7a',
                    bodyDark: '#3a2c6a',
                    outline: '#2a1c5a',
                    energy: '#9d4edd',
                    energyBright: '#c77dff'
                };
                
                let svg = '';
                
                switch (direction) {
                    case 'south':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Body -->
                                <rect x="12" y="8" width="8" height="16" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Head -->
                                <rect x="13" y="6" width="6" height="4" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Arms -->
                                <rect x="8" y="10" width="4" height="8" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <rect x="20" y="10" width="4" height="8" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Legs -->
                                <rect x="10" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <rect x="18" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Energy core -->
                                <rect x="14" y="12" width="4" height="4" fill="${colors.energy}"/>
                                <rect x="15" y="13" width="2" height="2" fill="${colors.energyBright}"/>
                            </svg>`;
                        break;
                    case 'north':
                        // Fixed north frame with visible neck and legs
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Legs (visible in back) -->
                                <rect x="10" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <rect x="18" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Body -->
                                <rect x="12" y="8" width="8" height="16" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Neck (visible) -->
                                <rect x="14" y="6" width="4" height="3" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Head -->
                                <rect x="13" y="4" width="6" height="4" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Arms -->
                                <rect x="8" y="10" width="4" height="8" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <rect x="20" y="10" width="4" height="8" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Energy core -->
                                <rect x="14" y="12" width="4" height="4" fill="${colors.energy}"/>
                                <rect x="15" y="13" width="2" height="2" fill="${colors.energyBright}"/>
                            </svg>`;
                        break;
                    case 'west':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Body -->
                                <rect x="12" y="8" width="8" height="16" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Head -->
                                <rect x="10" y="6" width="8" height="4" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Arm (visible) -->
                                <rect x="8" y="10" width="4" height="8" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Legs -->
                                <rect x="10" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <rect x="16" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Energy core -->
                                <rect x="14" y="12" width="4" height="4" fill="${colors.energy}"/>
                                <rect x="15" y="13" width="2" height="2" fill="${colors.energyBright}"/>
                            </svg>`;
                        break;
                    case 'east':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Body -->
                                <rect x="12" y="8" width="8" height="16" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Head -->
                                <rect x="14" y="6" width="8" height="4" fill="${colors.body}" stroke="${colors.outline}"/>
                                <!-- Arm (visible) -->
                                <rect x="20" y="10" width="4" height="8" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Legs -->
                                <rect x="12" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <rect x="18" y="24" width="4" height="6" fill="${colors.bodyDark}" stroke="${colors.outline}"/>
                                <!-- Energy core -->
                                <rect x="14" y="12" width="4" height="4" fill="${colors.energy}"/>
                                <rect x="15" y="13" width="2" height="2" fill="${colors.energyBright}"/>
                            </svg>`;
                        break;
                }
                
                return svg;
            }
            
            // Generate SVG for thermal fins overlay
            generateFinsSVG(direction) {
                const colors = {
                    fin: '#ff6b3a',
                    finDark: '#e55a2b',
                    outline: '#cc4a1c'
                };
                
                let svg = '';
                
                switch (direction) {
                    case 'south':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Back fins -->
                                <rect x="6" y="12" width="2" height="6" fill="${colors.fin}" stroke="${colors.outline}"/>
                                <rect x="24" y="12" width="2" height="6" fill="${colors.fin}" stroke="${colors.outline}"/>
                                <!-- Side fins -->
                                <rect x="10" y="14" width="2" height="4" fill="${colors.finDark}" stroke="${colors.outline}"/>
                                <rect x="20" y="14" width="2" height="4" fill="${colors.finDark}" stroke="${colors.outline}"/>
                            </svg>`;
                        break;
                    case 'north':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Front fins -->
                                <rect x="6" y="12" width="2" height="6" fill="${colors.finDark}" stroke="${colors.outline}"/>
                                <rect x="24" y="12" width="2" height="6" fill="${colors.finDark}" stroke="${colors.outline}"/>
                                <!-- Side fins -->
                                <rect x="10" y="14" width="2" height="4" fill="${colors.fin}" stroke="${colors.outline}"/>
                                <rect x="20" y="14" width="2" height="4" fill="${colors.fin}" stroke="${colors.outline}"/>
                            </svg>`;
                        break;
                    case 'west':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Side fins -->
                                <rect x="6" y="12" width="2" height="6" fill="${colors.fin}" stroke="${colors.outline}"/>
                                <rect x="22" y="14" width="2" height="4" fill="${colors.finDark}" stroke="${colors.outline}"/>
                            </svg>`;
                        break;
                    case 'east':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Side fins -->
                                <rect x="8" y="14" width="2" height="4" fill="${colors.finDark}" stroke="${colors.outline}"/>
                                <rect x="24" y="12" width="2" height="6" fill="${colors.fin}" stroke="${colors.outline}"/>
                            </svg>`;
                        break;
                }
                
                return svg;
            }
            
            // Generate SVG for radiant veil overlay
            generateVeilSVG(direction) {
                const colors = {
                    veil: '#c77dff',
                    veilBright: '#e0aaff',
                    outline: '#9d4edd'
                };
                
                let svg = '';
                
                switch (direction) {
                    case 'south':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Energy field -->
                                <ellipse cx="16" cy="16" rx="10" ry="8" fill="${colors.veil}" opacity="0.6" stroke="${colors.outline}"/>
                                <ellipse cx="16" cy="16" rx="6" ry="5" fill="${colors.veilBright}" opacity="0.8"/>
                                <!-- Particles -->
                                <circle cx="12" cy="12" r="1" fill="${colors.veilBright}"/>
                                <circle cx="20" cy="14" r="1" fill="${colors.veilBright}"/>
                                <circle cx="14" cy="20" r="1" fill="${colors.veilBright}"/>
                                <circle cx="18" cy="18" r="1" fill="${colors.veilBright}"/>
                            </svg>`;
                        break;
                    case 'north':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Energy field (doesn't occlude neck/legs) -->
                                <ellipse cx="16" cy="14" rx="8" ry="6" fill="${colors.veil}" opacity="0.6" stroke="${colors.outline}"/>
                                <ellipse cx="16" cy="14" rx="5" ry="4" fill="${colors.veilBright}" opacity="0.8"/>
                                <!-- Particles -->
                                <circle cx="12" cy="10" r="1" fill="${colors.veilBright}"/>
                                <circle cx="20" cy="12" r="1" fill="${colors.veilBright}"/>
                                <circle cx="14" cy="18" r="1" fill="${colors.veilBright}"/>
                                <circle cx="18" cy="16" r="1" fill="${colors.veilBright}"/>
                            </svg>`;
                        break;
                    case 'west':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Energy field -->
                                <ellipse cx="16" cy="16" rx="6" ry="10" fill="${colors.veil}" opacity="0.6" stroke="${colors.outline}"/>
                                <ellipse cx="16" cy="16" rx="4" ry="6" fill="${colors.veilBright}" opacity="0.8"/>
                                <!-- Particles -->
                                <circle cx="12" cy="12" r="1" fill="${colors.veilBright}"/>
                                <circle cx="18" cy="14" r="1" fill="${colors.veilBright}"/>
                                <circle cx="14" cy="20" r="1" fill="${colors.veilBright}"/>
                                <circle cx="20" cy="18" r="1" fill="${colors.veilBright}"/>
                            </svg>`;
                        break;
                    case 'east':
                        svg = `
                            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                                <!-- Energy field -->
                                <ellipse cx="16" cy="16" rx="6" ry="10" fill="${colors.veil}" opacity="0.6" stroke="${colors.outline}"/>
                                <ellipse cx="16" cy="16" rx="4" ry="6" fill="${colors.veilBright}" opacity="0.8"/>
                                <!-- Particles -->
                                <circle cx="12" cy="12" r="1" fill="${colors.veilBright}"/>
                                <circle cx="20" cy="14" r="1" fill="${colors.veilBright}"/>
                                <circle cx="14" cy="20" r="1" fill="${colors.veilBright}"/>
                                <circle cx="18" cy="18" r="1" fill="${colors.veilBright}"/>
                            </svg>`;
                        break;
                }
                
                return svg;
            }
            
            // Generate SVG for plasma flare animation frame
            generateFlareSVG(frame) {
                const colors = {
                    plasma: '#9d4edd',
                    ember: '#ff6b3a',
                    bright: '#e0aaff',
                    spark: '#ffaa44'
                };
                
                const progress = frame / 11; // 0 to 1
                const ringSize = 4 + (progress * 12); // Expanding rings
                const sparkCount = 8;
                const sparkDistance = 6 + (progress * 8);
                
                let svg = `<svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">`;
                
                // Central blast
                const coreSize = 2 + (progress * 4);
                svg += `<circle cx="16" cy="16" r="${coreSize}" fill="${colors.bright}" opacity="${1 - progress * 0.3}"/>`;
                
                // Expanding rings
                for (let i = 0; i < 3; i++) {
                    const ringRadius = ringSize + (i * 3);
                    const opacity = Math.max(0, 0.8 - progress - (i * 0.2));
                    if (opacity > 0) {
                        svg += `<circle cx="16" cy="16" r="${ringRadius}" fill="none" stroke="${colors.plasma}" stroke-width="2" opacity="${opacity}"/>`;
                    }
                }
                
                // Ember sparks
                for (let i = 0; i < sparkCount; i++) {
                    const angle = (i / sparkCount) * Math.PI * 2;
                    const distance = sparkDistance + (Math.sin(frame * 0.5 + i) * 2);
                    const x = 16 + Math.cos(angle) * distance;
                    const y = 16 + Math.sin(angle) * distance;
                    const sparkSize = 0.5 + (Math.random() * 1.5);
                    const opacity = Math.max(0, 1 - progress * 1.2);
                    
                    if (opacity > 0 && x >= 0 && x <= 32 && y >= 0 && y <= 32) {
                        svg += `<circle cx="${x}" cy="${y}" r="${sparkSize}" fill="${colors.ember}" opacity="${opacity}"/>`;
                    }
                }
                
                svg += '</svg>';
                return svg;
            }
            
            // Convert SVG to PNG using canvas
            async svgToPng(svgString) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);
                    
                    img.onload = () => {
                        this.ctx.clearRect(0, 0, 32, 32);
                        this.ctx.drawImage(img, 0, 0, 32, 32);
                        
                        this.canvas.toBlob((blob) => {
                            URL.revokeObjectURL(url);
                            if (blob) {
                                resolve(blob);
                            } else {
                                // Fallback for older browsers
                                const dataURL = this.canvas.toDataURL('image/png');
                                const byteString = atob(dataURL.split(',')[1]);
                                const ab = new ArrayBuffer(byteString.length);
                                const ia = new Uint8Array(ab);
                                for (let i = 0; i < byteString.length; i++) {
                                    ia[i] = byteString.charCodeAt(i);
                                }
                                resolve(new Blob([ab], { type: 'image/png' }));
                            }
                        }, 'image/png');
                    };
                    
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load SVG'));
                    };
                    
                    img.src = url;
                });
            }
            
            // Generate meta.json for RSI
            generateMetaJson(assetType) {
                const baseMetadata = {
                    version: 1,
                    license: "CC-BY-SA-3.0",
                    copyright: "Space Station 14",
                    size: { x: 32, y: 32 }
                };
                
                switch (assetType) {
                    case 'base':
                        return {
                            ...baseMetadata,
                            states: [{
                                name: "helion_base",
                                directions: 4
                            }]
                        };
                    case 'fins':
                        return {
                            ...baseMetadata,
                            states: [{
                                name: "helion_fins",
                                directions: 4
                            }]
                        };
                    case 'veil':
                        return {
                            ...baseMetadata,
                            states: [{
                                name: "helion_veil",
                                directions: 4
                            }]
                        };
                    case 'flare':
                        return {
                            ...baseMetadata,
                            states: [{
                                name: "helion_plasma_flare",
                                delays: Array(12).fill(0.06) // 60ms per frame
                            }]
                        };
                    default:
                        return baseMetadata;
                }
            }
            
            // Generate and download single asset
            async generateAsset(assetType) {
                const zip = new JSZip();
                const metadata = this.generateMetaJson(assetType);
                
                try {
                    if (assetType === 'flare') {
                        // Generate animation frames
                        for (let frame = 0; frame < 12; frame++) {
                            const svg = this.generateFlareSVG(frame);
                            const pngBlob = await this.svgToPng(svg);
                            zip.file(`helion_plasma_flare-${frame}.png`, pngBlob);
                        }
                    } else {
                        // Generate 4 direction sprites
                        const directions = ['south', 'north', 'west', 'east'];
                        const stateName = metadata.states[0].name;
                        
                        for (let i = 0; i < 4; i++) {
                            let svg = '';
                            switch (assetType) {
                                case 'base':
                                    svg = this.generateBaseSVG(directions[i]);
                                    break;
                                case 'fins':
                                    svg = this.generateFinsSVG(directions[i]);
                                    break;
                                case 'veil':
                                    svg = this.generateVeilSVG(directions[i]);
                                    break;
                            }
                            
                            const pngBlob = await this.svgToPng(svg);
                            zip.file(`${stateName}-${i}.png`, pngBlob);
                        }
                    }
                    
                    // Add meta.json
                    zip.file('meta.json', JSON.stringify(metadata, null, 2));
                    
                    return await zip.generateAsync({ type: 'blob', compression: 'STORE' });
                } catch (error) {
                    console.error('Error generating asset:', error);
                    throw error;
                }
            }
            
            // Download file with proper filename
            downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // Generate preview sprites for UI
            async generatePreviews() {
                try {
                    // Base body previews
                    const basePreview = document.getElementById('base-preview');
                    const directions = ['south', 'north', 'west', 'east'];
                    
                    for (let i = 0; i < 4; i++) {
                        const svg = this.generateBaseSVG(directions[i]);
                        const blob = await this.svgToPng(svg);
                        const url = URL.createObjectURL(blob);
                        const img = document.createElement('img');
                        img.src = url;
                        img.className = 'direction-sprite';
                        img.title = directions[i];
                        basePreview.appendChild(img);
                    }
                    
                    // Fins previews
                    const finsPreview = document.getElementById('fins-preview');
                    for (let i = 0; i < 4; i++) {
                        const svg = this.generateFinsSVG(directions[i]);
                        const blob = await this.svgToPng(svg);
                        const url = URL.createObjectURL(blob);
                        const img = document.createElement('img');
                        img.src = url;
                        img.className = 'direction-sprite';
                        img.title = directions[i];
                        finsPreview.appendChild(img);
                    }
                    
                    // Veil previews
                    const veilPreview = document.getElementById('veil-preview');
                    for (let i = 0; i < 4; i++) {
                        const svg = this.generateVeilSVG(directions[i]);
                        const blob = await this.svgToPng(svg);
                        const url = URL.createObjectURL(blob);
                        const img = document.createElement('img');
                        img.src = url;
                        img.className = 'direction-sprite';
                        img.title = directions[i];
                        veilPreview.appendChild(img);
                    }
                    
                    // Flare animation frames
                    const flarePreview = document.getElementById('flare-preview');
                    this.flareFrames = [];
                    
                    for (let frame = 0; frame < 12; frame++) {
                        const svg = this.generateFlareSVG(frame);
                        const blob = await this.svgToPng(svg);
                        const url = URL.createObjectURL(blob);
                        const img = document.createElement('img');
                        img.src = url;
                        img.className = 'preview-sprite';
                        if (frame === 0) img.classList.add('active');
                        flarePreview.appendChild(img);
                        this.flareFrames.push(img);
                    }
                    
                } catch (error) {
                    console.error('Error generating previews:', error);
                }
            }
            
            // Animate plasma flare preview
            startFlareAnimation() {
                let currentFrame = 0;
                setInterval(() => {
                    if (this.flareFrames && this.flareFrames.length > 0) {
                        this.flareFrames.forEach(img => img.classList.remove('active'));
                        this.flareFrames[currentFrame].classList.add('active');
                        currentFrame = (currentFrame + 1) % this.flareFrames.length;
                    }
                }, 60); // 60ms per frame
            }
        }
        
        // Global instance
        let assetGenerator;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            assetGenerator = new HelionAssetGenerator();
        });
        
        // Download single asset
        async function downloadAsset(assetType) {
            const statusElement = document.getElementById(`${assetType}-status`);
            const button = event.target;
            
            try {
                button.disabled = true;
                statusElement.textContent = 'Generating...';
                statusElement.className = 'status';
                
                const blob = await assetGenerator.generateAsset(assetType);
                const filename = `helion_${assetType}.rsi`;
                
                assetGenerator.downloadBlob(blob, filename);
                
                statusElement.textContent = 'âœ“ Downloaded successfully!';
                statusElement.className = 'status success';
                
            } catch (error) {
                console.error('Download error:', error);
                statusElement.textContent = `âœ— Error: ${error.message}`;
                statusElement.className = 'status error';
            } finally {
                button.disabled = false;
                setTimeout(() => {
                    statusElement.textContent = '';
                    statusElement.className = 'status';
                }, 3000);
            }
        }
        
        // Download all assets
        async function downloadAll() {
            const statusElement = document.getElementById('master-status');
            const button = event.target;
            
            try {
                button.disabled = true;
                statusElement.textContent = 'Generating all assets...';
                statusElement.className = 'status';
                
                const masterZip = new JSZip();
                const assetTypes = ['base', 'fins', 'veil', 'flare'];
                
                for (const assetType of assetTypes) {
                    statusElement.textContent = `Generating ${assetType}...`;
                    const assetBlob = await assetGenerator.generateAsset(assetType);
                    masterZip.file(`helion_${assetType}.rsi`, assetBlob);
                }
                
                statusElement.textContent = 'Creating master package...';
                const masterBlob = await masterZip.generateAsync({ 
                    type: 'blob', 
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });
                
                assetGenerator.downloadBlob(masterBlob, 'helion_all_assets.zip');
                
                statusElement.textContent = 'âœ“ All assets downloaded!';
                statusElement.className = 'status success';
                
            } catch (error) {
                console.error('Master download error:', error);
                statusElement.textContent = `âœ— Error: ${error.message}`;
                statusElement.className = 'status error';
            } finally {
                button.disabled = false;
                setTimeout(() => {
                    statusElement.textContent = '';
                    statusElement.className = 'status';
                }, 3000);
            }
        }
    </script>
</body>
</html>